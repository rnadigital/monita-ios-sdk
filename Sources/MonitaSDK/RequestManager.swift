//
//  RequestManager.swift
//  AppGlobalDemo
//
//  Created by Coderon 10/09/24.
//


/*
 t: User-provided token
 dm: Deployment method. "app" for SDK based deployments
 mv: SDK Version
 tm: Unix time in seconds with milliseconds (optional) as decimals
 e: Vendor Event. The event is evaluated in the following order:
 SDK config: event evaluation function (future release)
 Vendor event field in Deployment config eventParameter
 event parameter value if the key exists
 ev parameter value if the key exists
 
 vn: Vendor name (case senstive and with spaces preserved)
 st: tag status (can we get HTTP call status? 200) If so, value is either success or failed
 m: HTTP method
 vu: captured HTTP call endpoint URL
 u: App ID
 p: App area (future release) or NULL if not provided
 dt: Payload content as JSON in Array, so top level of JSON is Array of payload objects. This si useful where calls and payloads are batched
 s: System : android-sdk or ios-sdk
 rl: Release aka SDK version number
 env: Default "production". Can be user configured in future releases
 do: Host app version
 et: executon time in seconds, or 0
 vid: hard-coded "1"
 cn: Consent string value
 sid: Session ID. SDK generated by default or can be overwritten in SDK config by a dynamic evaluation function
 cid: Customer ID. null or SDK generated by default or can be overwritten in SDK config by a dynamic evaluation function
 */

import Foundation
import UIKit

class RequestManager: @unchecked Sendable {
    static let shared = RequestManager()
    private var configuration: MonitaConfiguration?
    private var cachedDeviceModel: String?
    private var cachedSystemVersion: String?
    
    private init() {}
    
    @MainActor
    func cacheDeviceInfo() {
        cachedDeviceModel = UIDevice.current.model
        cachedSystemVersion = UIDevice.current.systemVersion
    }
    
    public func setConfiguration(configuration: MonitaConfiguration?) {
        if let configuration {
            self.configuration = configuration
        }
    }
}

extension RequestManager {
    /// Asynchronously retrieves all intercepted requests from storage,
    
    func sendInterceptedRequestsOneByOne() async {
        
        let allRequests = await InterceptedRequestStore.shared.allRequests()
        guard !allRequests.isEmpty else {
            MonitaLogger.shared.debug(message: .message("No Intercepted requests to upload"))
            return
        }
        
        // Iterate over them one at a time
        for intercepted in allRequests {
            
            guard let vendor = intercepted.vendors.first else {
                // If no vendors, just remove from store.
                await InterceptedRequestStore.shared.remove(intercepted)
                continue
            }
            
            let finalPayload = await buildPayload(intercepted, vendor: vendor)
            
            // Attempt to send with a retry approach. If it fails after max tries, remove from store.
            let success = await uploadWithRetry(payload: finalPayload)
            
            if success {
                MonitaLogger.shared.debug(message: .message("Successfully uploaded request for vendor: \(vendor.vendorName ?? "(unknown)")"))
            } else {
                MonitaLogger.shared.debug(message: .message("Failed to upload request after \(configuration?.maxRetries) tries. Removing from store."))
            }
            
            // Remove the request from the store in ANY case (success or final failure).
            await InterceptedRequestStore.shared.remove(intercepted)
        }
    }
    
    private func uploadWithRetry(payload: [String: Any]) async -> Bool {
        let maxAttempts = configuration?.maxRetries ?? 3
        let baseDelay = configuration?.baseDelay ?? 1.0
        
        var attempt = 0
        var delaySeconds = baseDelay
        
        while attempt < maxAttempts {
            do {
                let success = try await sendToServerAsync(payload: payload)
                if success {
                    // If we got a 2xx success, we can stop
                    MonitaLogger.shared.debug(message: .message("2xx success. Attempt \(attempt + 1) of \(maxAttempts)."))
                    return true
                }
                // Non-2xx
                MonitaLogger.shared.debug(message: .message("Non-2xx response. Attempt \(attempt + 1) of \(maxAttempts)."))
            } catch {
                // E.g. network error
                MonitaLogger.shared.debug(message: .message("Error uploading on attempt \(attempt + 1) of \(maxAttempts): \(error)"))
            }
            
            attempt += 1
            if attempt < maxAttempts {
                // Sleep for delaySeconds
                try? await Task.sleep(nanoseconds: UInt64(delaySeconds * 1_000_000_000))
                // Double the delay
                delaySeconds *= 2
            }
        }
        
        // If we exit the loop, we failed all attempts
        return false
    }
    
    /// Async method to send a payload to the backend using URLSession.
    private func sendToServerAsync(payload: Parameter) async throws -> Bool {
        guard let url = URL(string: configuration?.endpointPOSTURL ?? "") else {
            throw URLError(.badURL)
        }
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        // Convert to JSON
        let jsonData = try JSONSerialization.data(withJSONObject: payload, options: [])
        request.httpBody = jsonData
        
        let (_, response) = try await URLSession.shared.data(for: request)
        guard let httpResponse = response as? HTTPURLResponse,
              (200...299).contains(httpResponse.statusCode)
        else {
            return false
        }
        return true
    }
    
    /// Build the final payload dictionary from an InterceptedRequest
    private func buildPayload(_ intercepted: InterceptedRequest, vendor: Vendor) async -> [String: Any] {
        
        
        var requestDict: [String: Any] = [
            "url": intercepted.url,
            "method": intercepted.method,
            "statusCode": intercepted.statusCode ?? -1,
            "headers": intercepted.headers
        ]
        if let bodyData = intercepted.body,
           let bodyString = String(data: bodyData, encoding: .utf8) {
            requestDict["body"] = bodyString
        }
        if let respData = intercepted.responseBody,
           let respString = String(data: respData, encoding: .utf8) {
            requestDict["responseBody"] = respString
        }
        
        if let body = requestDict["body"] as? String,
           let excludeParameters = vendor.execludeParameters {
            
            var bodyDic = body.dictionary() // 'dictionary()' is presumably your extension that parses JSON from string
            // remove entries whose value matches any excludeParameter
            for excludeValue in excludeParameters {
                bodyDic.forEach { key, val in
                    if (val as? String) == excludeValue {
                        bodyDic.removeValue(forKey: key)
                    }
                }
            }
            
            // Re-encode into JSON text
            let updatedBodyStr = bodyDic.jsonString
            requestDict["body"] = updatedBodyStr
        }
        let timestamp = String(Date().timeIntervalSince1970)
        let vendorName = vendor.vendorName ?? ""
        let eventParam = vendor.eventParamter ?? ""
        
        let finalPayload: [String: Any] = [
            "t": MonitaSDK.shared.token,
            "dm": "app",
            "mv": "1.0", // or from your old logic
            "sv": cachedSystemVersion ?? "Device version is missing",
            "tm": timestamp,
            "e": eventParam,
            "vn": vendorName,
            "st": "success",
            "m": intercepted.method,
            "vu": intercepted.url,
            "u": Bundle.main.bundleIdentifier ?? "",
            "p": "",
            "dt": [requestDict],
            "s": "ios-sdk",
            "rl": "1.0",
            "env": "production",
            "et": "1",
            "vid": "1",
            "cn": "",
            "sid": "",
            "cid": MonitaSDK.shared.cid,
            "ev": ""
        ]
        return finalPayload
    }
    
}
